package mcpews.listeners;

import mcpews.*;
import java.awt.Color;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.logging.StreamHandler;
import javax.swing.DefaultListModel;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import mcpews.command.CommandType;
import mcpews.command.SayCommand;
import mcpews.event.*;
import mcpews.logger.*;
import mcpews.message.*;
import mcpews.util.ChatFormatCode;

/**
 *
 * @author Jocopa3
 */
public class ServerGUI extends javax.swing.JFrame implements MCListener {

    private MCSocketServer server;
    DefaultListModel<String> clientListModel;
    private final Logger messageLogger = Logger.getLogger("PEWS-MessageLog");
    private final TextAreaLogger textLogger;

    private boolean isRunning = false;

    private LogFilter filter;

    /**
     * Creates new form ServerGUI
     */
    public ServerGUI() {
        initComponents();

        clientListModel = new DefaultListModel<>();
        clientList.setModel(clientListModel);

        textLogger = new TextAreaLogger(logTextPane);
        messageLogger.addHandler(textLogger);

        filter = new LogFilter();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        clientPopupMenu = new javax.swing.JPopupMenu();
        disconnectClientMenuItem = new javax.swing.JMenuItem();
        SplitPane = new javax.swing.JSplitPane();
        logPanel = new javax.swing.JPanel();
        inputTextField = new javax.swing.JTextField();
        portSpinner = new javax.swing.JSpinner();
        portTextLabel = new javax.swing.JLabel();
        startButton = new javax.swing.JButton();
        stopButton = new javax.swing.JButton();
        useLocalHostCheckBox = new javax.swing.JCheckBox();
        logTextScrollPane = new javax.swing.JScrollPane();
        logTextPane = new javax.swing.JTextPane();
        clientPanel = new javax.swing.JPanel();
        clientScrollPane = new javax.swing.JScrollPane();
        clientList = new javax.swing.JList<String>();
        clientLabel = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu3 = new javax.swing.JMenu();
        jMenu1 = new javax.swing.JMenu();
        logAllCheckBox = new javax.swing.JCheckBoxMenuItem();
        logChatCheckBox = new javax.swing.JCheckBoxMenuItem();
        logDebugCheckBox = new javax.swing.JCheckBoxMenuItem();
        logInfoCheckBox = new javax.swing.JCheckBoxMenuItem();
        logWarningsCheckBox = new javax.swing.JCheckBoxMenuItem();
        logSevereCheckBox = new javax.swing.JCheckBoxMenuItem();

        disconnectClientMenuItem.setText("jMenuItem1");
        disconnectClientMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                disconnectClientMenuItemActionPerformed(evt);
            }
        });
        clientPopupMenu.add(disconnectClientMenuItem);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        inputTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                inputTextFieldKeyPressed(evt);
            }
        });

        portSpinner.setEditor(new javax.swing.JSpinner.NumberEditor(portSpinner, ""));
        portSpinner.setRequestFocusEnabled(false);
        portSpinner.setValue(19232);

        portTextLabel.setText("Port:");

        startButton.setBackground(new java.awt.Color(102, 255, 102));
        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        stopButton.setBackground(new java.awt.Color(255, 102, 102));
        stopButton.setText("Stop");
        stopButton.setEnabled(false);
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopButtonActionPerformed(evt);
            }
        });

        useLocalHostCheckBox.setSelected(true);
        useLocalHostCheckBox.setText("LocalHost");

        logTextPane.setEditable(false);
        logTextPane.setBackground(new java.awt.Color(229, 238, 255));
        logTextScrollPane.setViewportView(logTextPane);

        javax.swing.GroupLayout logPanelLayout = new javax.swing.GroupLayout(logPanel);
        logPanel.setLayout(logPanelLayout);
        logPanelLayout.setHorizontalGroup(
            logPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(logPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(logPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(inputTextField)
                    .addGroup(logPanelLayout.createSequentialGroup()
                        .addComponent(startButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stopButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 45, Short.MAX_VALUE)
                        .addComponent(useLocalHostCheckBox)
                        .addGap(18, 18, 18)
                        .addComponent(portTextLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(portSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
            .addComponent(logTextScrollPane)
        );
        logPanelLayout.setVerticalGroup(
            logPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(logPanelLayout.createSequentialGroup()
                .addComponent(logTextScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 341, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(logPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(portTextLabel)
                    .addComponent(portSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(startButton)
                    .addComponent(stopButton)
                    .addComponent(useLocalHostCheckBox))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inputTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        SplitPane.setRightComponent(logPanel);

        clientScrollPane.setViewportView(clientList);

        clientLabel.setFont(new java.awt.Font("Tahoma", 1, 19)); // NOI18N
        clientLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        clientLabel.setText("Connected Clients");

        javax.swing.GroupLayout clientPanelLayout = new javax.swing.GroupLayout(clientPanel);
        clientPanel.setLayout(clientPanelLayout);
        clientPanelLayout.setHorizontalGroup(
            clientPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(clientLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 202, Short.MAX_VALUE)
            .addComponent(clientScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
        );
        clientPanelLayout.setVerticalGroup(
            clientPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, clientPanelLayout.createSequentialGroup()
                .addComponent(clientLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(clientScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 365, Short.MAX_VALUE))
        );

        SplitPane.setLeftComponent(clientPanel);

        jMenu3.setText("Options");

        jMenu1.setText("Filter Log...");

        logAllCheckBox.setText("Log All Events");
        logAllCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logAllCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logAllCheckBox);

        logChatCheckBox.setSelected(true);
        logChatCheckBox.setText("Log Chat Events");
        logChatCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logChatCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logChatCheckBox);

        logDebugCheckBox.setText("Log Debug Events");
        logDebugCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logDebugCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logDebugCheckBox);

        logInfoCheckBox.setSelected(true);
        logInfoCheckBox.setText("Log Info Events");
        logInfoCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logInfoCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logInfoCheckBox);

        logWarningsCheckBox.setSelected(true);
        logWarningsCheckBox.setText("Log Warning Events");
        logWarningsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logWarningsCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logWarningsCheckBox);

        logSevereCheckBox.setSelected(true);
        logSevereCheckBox.setText("Log Severe Events");
        logSevereCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logSevereCheckBoxActionPerformed(evt);
            }
        });
        jMenu1.add(logSevereCheckBox);

        jMenu3.add(jMenu1);

        jMenuBar1.add(jMenu3);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(SplitPane)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(SplitPane)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        createServer();
    }//GEN-LAST:event_startButtonActionPerformed

    private void stopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopButtonActionPerformed
        stopServer();
    }//GEN-LAST:event_stopButtonActionPerformed

    private void inputTextFieldKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_inputTextFieldKeyPressed
        switch (evt.getKeyCode()) {
            case 10:
                parseChatInput(inputTextField.getText());
                inputTextField.setText("");
                break;
            default:
                return;
        }
    }//GEN-LAST:event_inputTextFieldKeyPressed

    private void disconnectClientMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_disconnectClientMenuItemActionPerformed

    }//GEN-LAST:event_disconnectClientMenuItemActionPerformed

    private void logInfoCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logInfoCheckBoxActionPerformed
        filter.shouldLogInfo(logInfoCheckBox.isSelected());
        textLogger.filter(filter);
    }//GEN-LAST:event_logInfoCheckBoxActionPerformed

    private void logSevereCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logSevereCheckBoxActionPerformed
        filter.shouldLogSevere(logSevereCheckBox.isSelected());
        textLogger.filter(filter);
    }//GEN-LAST:event_logSevereCheckBoxActionPerformed

    private void logAllCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logAllCheckBoxActionPerformed
        boolean allSelected = logAllCheckBox.isSelected();
        filter.shouldLogAll(allSelected);

        logChatCheckBox.setEnabled(!allSelected);
        logDebugCheckBox.setEnabled(!allSelected);
        logInfoCheckBox.setEnabled(!allSelected);
        logWarningsCheckBox.setEnabled(!allSelected);
        logSevereCheckBox.setEnabled(!allSelected);

        textLogger.filter(filter);
    }//GEN-LAST:event_logAllCheckBoxActionPerformed

    private void logChatCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logChatCheckBoxActionPerformed
        filter.shouldLogChat(logChatCheckBox.isSelected());
        textLogger.filter(filter);
    }//GEN-LAST:event_logChatCheckBoxActionPerformed

    private void logDebugCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logDebugCheckBoxActionPerformed
        filter.shouldLogDebug(logDebugCheckBox.isSelected());
        textLogger.filter(filter);
    }//GEN-LAST:event_logDebugCheckBoxActionPerformed

    private void logWarningsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logWarningsCheckBoxActionPerformed
        filter.shouldLogWarnings(logWarningsCheckBox.isSelected());
        textLogger.filter(filter);
    }//GEN-LAST:event_logWarningsCheckBoxActionPerformed

    /* 
     * Splits a string by spaces, but ignores spaces when inside brackets or quotes
     * This is meant to be faster and less error-prone than using regex.
     * 
     * For example, a string of: @a[name=Monkey Wrench, m = -1 ] "Super User" one two
     * evaluates to:
     * @a[name=Monkey Wrench, m = -1 ]
     * "Super User"
     * one
     * two
     */
    private String[] splitCommandText(String commandText) {
        int length = commandText.length();
        ArrayList<String> parameters = new ArrayList<>();

        StringBuilder currentString = new StringBuilder();
        int inBrackets = 0;
        boolean inQuotes = false;

        for (int i = 0; i < length; i++) {
            char c = commandText.charAt(i);

            switch (c) {
                case '"':
                    inQuotes = !inQuotes;
                    break;
                case '[':
                    inBrackets++;
                    break;
                case ']':
                    inBrackets--;
                    break;
            }

            if (inBrackets == 0 && !inQuotes && c == ' ') {
                parameters.add(currentString.toString());
                currentString.delete(0, currentString.length());
            } else {
                currentString.append(c);

                if (i == length - 1) {
                    parameters.add(currentString.toString());
                    currentString.delete(0, currentString.length());
                }
            }
        }

        return parameters.toArray(new String[0]);
    }

    // Ugliest, function, ever.
    private void parseChatInput(String input) {
        if (input.startsWith("/")) { // Send command message
            CommandType command = CommandType.fromChatString(input);

            // Inform the user if the command name is invalid
            if (command == null) {
                server.getLog().log(LogLevel.INFO, "Unknown command: {0}", input);
                return;
            }

            // Parameters should store all string parameters following the /command input
            // Possible bug when typing a space between '/' and the command name like: / summon tnt
            String[] parameters = splitCommandText(input.replaceFirst("/" + command.getName() + " ", ""));
            MCCommand commandRequest = null;

            // Get all constructors and loop through them
            // Try to initialize the command object using each constructor
            Class commandClass = command.getRequestClass();
            Constructor[] constructors = commandClass.getConstructors();

            for (Constructor constructor : constructors) {
                Class[] params = constructor.getParameterTypes();

                int paramIndx = 0, objIndx = 0;

                Object[] objects = new Object[params.length];

                // Try to create each object in the constructor by passing the parameter strings
                try {
                    for (Class paramType : params) {
                        Constructor paramCtor;
                        try {
                            paramCtor = paramType.getConstructor(String.class);
                            if (paramCtor != null) {
                                objects[objIndx] = paramCtor.newInstance(parameters[paramIndx]);
                                objIndx++;
                                paramIndx++;
                                continue;
                            }
                        } catch (Exception e) {
                        }
                        
                        try {
                            paramCtor = paramType.getConstructor(String.class, String.class);
                            if (paramCtor != null) {
                                objects[objIndx] = paramCtor.newInstance(parameters[paramIndx], parameters[paramIndx + 1]);
                                objIndx++;
                                paramIndx += 2;
                                continue;
                            }
                        } catch (Exception e) {
                        }
                        
                        try {
                            paramCtor = paramType.getConstructor(String.class, String.class, String.class);
                            if (paramCtor != null) {
                                objects[objIndx] = paramCtor.newInstance(parameters[paramIndx], parameters[paramIndx + 1], parameters[paramIndx + 2]);
                                objIndx++;
                                paramIndx += 3;
                                continue;
                            }
                        } catch (Exception e) {
                            break;
                        }
                    }
                    
                    if (paramIndx != parameters.length) {
                        continue;
                    }

                    commandRequest = (MCCommand) constructor.newInstance(objects);
                    break;
                } catch (Exception e) {
                    continue;
                }
            }

            // Inform the user if the command couldn't be parsed
            if (commandRequest == null) {
                server.getLog().log(LogLevel.INFO, "Couldn't parse command: " + input);
                return;
            }

            sendCommandToAll(commandRequest);
        } else { // Send chat message
            sendMessageToAll(input);
        }
    }

    private void sendCommandToAll(MCCommand command) {
        if (!isRunning || server == null) {
            return;
        }

        Collection<MCClient> con = server.getClients();
        synchronized (con) {
            for (MCClient client : con) {
                client.send(this, command);
            }
        }
    }

    private void sendMessageToAll(String message) {
        if (!isRunning || server == null) {
            return;
        }

        server.getLog().log(LogLevel.CHAT, "External: {0}",
                inputTextField.getText()
        );

        MCCommand cm = new SayCommand(message);
        //MCSocketServer.messageLogger.log(LogLevel.DEBUG, cm.getMessage().getMessageText());
        Collection<MCClient> con = server.getClients();
        synchronized (con) {
            for (MCClient client : con) {
                client.send(this, cm);
            }
        }
    }

    private void initializeListeners(MCSocketServer server) {
        server.addListener(this);

        HideAndSeekListener hide = new HideAndSeekListener(server);
        server.addListener(hide);
        
        //ChatListener chat = new ChatListener(server);
        //server.addListener(chat);

        DebugListener debug = new DebugListener();
        for (EventType event : EventType.values()) {
            // debug.addEvent(event);
        }
        //server.addListener(debug);

        //NukemListener nuke = new NukemListener();
        //server.addListener(nuke);
    }

    private void createServer() {
        if (isRunning) {
            messageLogger.log(Level.FINE, "Server is already running.");
            return;
        }

        String host;
        if (useLocalHostCheckBox.isSelected()) {
            host = "localhost";
        } else {
            try {
                host = InetAddress.getLocalHost().getHostName();
            } catch (UnknownHostException ex) {
                messageLogger.log(Level.SEVERE, null, ex);
                host = "localhost";
            }
        }

        int port = (Integer) portSpinner.getValue();

        server = new MCSocketServer(new InetSocketAddress(host, port));

        Thread t = new Thread(server);
        t.start();

        try {
            initializeListeners(server);
        } catch (Exception e) {
            stopServer();
            e.printStackTrace();
            return;
        }

        isRunning = true;

        startButton.setEnabled(false);
        stopButton.setEnabled(true);
    }

    private void stopServer() {
        if (!isRunning) {
            messageLogger.log(Level.FINE, "No servers are running.");
            return;
        }

        messageLogger.log(Level.INFO, "Stopping server: {0}:" + server.getAddress().getPort(), new Object[]{server.getAddress().getHostString()});
        MCCommand cm = new SayCommand("\u00a7cPEWS server is shutting down...");

        Collection<MCClient> con = server.getClients();
        synchronized (con) {
            for (MCClient client : con) {
                client.send(this, cm);
                client.close();
            }
        }

        try {
            Thread.sleep(150);
        } catch (InterruptedException ex) {
            //Logger.getLogger(ServerGUI.class.getName()).log(Level.SEVERE, null, ex);
        }

        try {
            server.stop(1000);
        } catch (IOException ex) {
            messageLogger.log(Level.SEVERE, null, ex);
        } catch (InterruptedException ex) {
            messageLogger.log(Level.SEVERE, "Server was interrupted.", ex);
        }

        isRunning = false;
        clientListModel.clear();

        startButton.setEnabled(true);
        stopButton.setEnabled(false);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
 /*
         try {
         for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
         if ("Nimbus".equals(info.getName())) {
         javax.swing.UIManager.setLookAndFeel(info.getClassName());
         break;
         }
         }
         } catch (ClassNotFoundException ex) {
         java.util.logging.Logger.getLogger(ServerGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
         } catch (InstantiationException ex) {
         java.util.logging.Logger.getLogger(ServerGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
         } catch (IllegalAccessException ex) {
         java.util.logging.Logger.getLogger(ServerGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
         } catch (javax.swing.UnsupportedLookAndFeelException ex) {
         java.util.logging.Logger.getLogger(ServerGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
         }
         */
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                ServerGUI gui = new ServerGUI();

                gui.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
                gui.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
                        gui.stopServer();
                        gui.dispose();
                        System.exit(0);
                    }
                });

                gui.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JSplitPane SplitPane;
    private javax.swing.JLabel clientLabel;
    private javax.swing.JList<String> clientList;
    private javax.swing.JPanel clientPanel;
    private javax.swing.JPopupMenu clientPopupMenu;
    private javax.swing.JScrollPane clientScrollPane;
    private javax.swing.JMenuItem disconnectClientMenuItem;
    private javax.swing.JTextField inputTextField;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JCheckBoxMenuItem logAllCheckBox;
    private javax.swing.JCheckBoxMenuItem logChatCheckBox;
    private javax.swing.JCheckBoxMenuItem logDebugCheckBox;
    private javax.swing.JCheckBoxMenuItem logInfoCheckBox;
    private javax.swing.JPanel logPanel;
    private javax.swing.JCheckBoxMenuItem logSevereCheckBox;
    private javax.swing.JTextPane logTextPane;
    private javax.swing.JScrollPane logTextScrollPane;
    private javax.swing.JCheckBoxMenuItem logWarningsCheckBox;
    private javax.swing.JSpinner portSpinner;
    private javax.swing.JLabel portTextLabel;
    private javax.swing.JButton startButton;
    private javax.swing.JButton stopButton;
    private javax.swing.JCheckBox useLocalHostCheckBox;
    // End of variables declaration//GEN-END:variables

    @Override
    public void onResponse(MCClient client, MCMessage response, MCMessage request) {
        //String responseMessage = (response.getBody()).toString();

        //if (responseMessage != null) {
            //server.getLog().log(LogLevel.INFO, "{0}", responseMessage);
        //}
    }

    @Override
    public void onEvent(MCClient client, MCMessage eventMessage) {
    }

    @Override
    public void onError(MCClient client, MCMessage response, MCMessage request) {
        //String responseMessage = (response.getBody()).toString();

        //if (responseMessage != null) {
            //server.getLog().log(LogLevel.INFO, "{0}", responseMessage);
        //}
    }

    @Override
    public void onConnected(MCClient client) {
        MCCommand say = new SayCommand("§bPEWS§e Test Server v0.0.1");
        client.send(this, say);

        this.clientListModel.addElement(client.toString());
    }

    @Override
    public void onDisconnected(MCClient client) {
        this.clientListModel.removeElement(client.toString());
    }

    class TextAreaLogger extends StreamHandler {

        private LinkedList<LogRecord> records;

        private JTextPane textPane;
        private StyledDocument document;

        private final SimpleDateFormat dateFormat;

        private Color warningColor;
        private Color background;
        private Color darkerBackground;

        private final SimpleAttributeSet dateKeyword;
        private final SimpleAttributeSet levelKeyword;
        private final SimpleAttributeSet messageKeyword;

        private final SimpleFormatter formatter;

        public TextAreaLogger(JTextPane textPane) {
            records = new LinkedList<>();
            dateFormat = new SimpleDateFormat("HH:mm:ss");

            dateKeyword = new SimpleAttributeSet();
            StyleConstants.setItalic(dateKeyword, true);

            levelKeyword = new SimpleAttributeSet();
            StyleConstants.setBold(levelKeyword, true);

            messageKeyword = new SimpleAttributeSet();

            formatter = new SimpleFormatter();

            warningColor = new Color(229, 197, 36);

            setTextArea(textPane);
        }

        public void setTextArea(JTextPane textPane) {
            this.textPane = textPane;
            document = textPane.getStyledDocument();
            background = textPane.getBackground();
            darkerBackground = background.darker();
        }

        private boolean getChatFormat(SimpleAttributeSet attributes, char formatCode) {
            switch (formatCode) {
                default:
                    return false;
                case ChatFormatCode.AQUA_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.AQUA);
                    StyleConstants.setBackground(attributes, darkerBackground);
                    break;
                case ChatFormatCode.BLACK_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.BLACK);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.BLUE_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.BLUE);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.BOLD_CHAR:
                    StyleConstants.setBold(attributes, true);
                    break;
                case ChatFormatCode.DARK_AQUA_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_AQUA);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.DARK_BLUE_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_BLUE);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.DARK_GRAY_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_GRAY);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.DARK_GREEN_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_GREEN);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.DARK_PURPLE_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_PURPLE);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.DARK_RED_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.DARK_RED);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.GOLD_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.GOLD);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.GRAY_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.GRAY);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.GREEN_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.GREEN);
                    StyleConstants.setBackground(attributes, darkerBackground);
                    break;
                case ChatFormatCode.ITALIC_CHAR:
                    StyleConstants.setItalic(attributes, true);
                    break;
                case ChatFormatCode.LIGHT_PURPLE_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.LIGHT_PURPLE);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.OBFUSCATED_CHAR:
                    break;
                case ChatFormatCode.RED_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.RED);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.RESET_CHAR:
                    StyleConstants.setBold(attributes, false);
                    StyleConstants.setItalic(attributes, false);
                    StyleConstants.setStrikeThrough(attributes, false);
                    StyleConstants.setUnderline(attributes, false);
                    StyleConstants.setForeground(attributes, ChatFormatCode.BLACK);
                    StyleConstants.setBackground(attributes, background);
                    break;
                case ChatFormatCode.STRIKETHROUGH_CHAR:
                    StyleConstants.setStrikeThrough(attributes, true);
                    break;
                case ChatFormatCode.UNDERLINE_CHAR:
                    StyleConstants.setUnderline(attributes, true);
                    break;
                case ChatFormatCode.WHITE_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.WHITE);
                    StyleConstants.setBackground(attributes, darkerBackground);
                    break;
                case ChatFormatCode.YELLOW_CHAR:
                    StyleConstants.setForeground(attributes, ChatFormatCode.YELLOW);
                    StyleConstants.setBackground(attributes, darkerBackground);
                    break;
            }

            return true;
            //return chatFormatting;
        }

        private void writeChatString(String text) throws BadLocationException {
            SimpleAttributeSet chatFormatting = new SimpleAttributeSet();

            String[] tokens = text.split("\u00a7");
            for (String token : tokens) {
                if (token.trim().isEmpty()) {
                    continue;
                }

                if (getChatFormat(chatFormatting, token.charAt(0))) {
                    append(token.substring(1), chatFormatting);
                } else {
                    append(token.substring(0), chatFormatting);
                }
            }
        }

        private void append(String text, SimpleAttributeSet attribute) throws BadLocationException {
            document.insertString(document.getLength(), text, attribute);
        }

        public void filterLevel(Level level) {
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    try {
                        document.remove(0, document.getLength());

                        for (LogRecord record : records) {
                            if (level.intValue() == Level.ALL.intValue() || record.getLevel().intValue() == level.intValue()) {
                                writeRecord(record);
                            }
                        }
                    } catch (BadLocationException ex) {
                        Logger.getLogger(ServerGUI.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            });
        }

        public void filter(LogFilter filter) {
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    try {
                        document.remove(0, document.getLength());

                        for (LogRecord record : records) {
                            if (filter.logAll) {
                                writeRecord(record);
                            } else {
                                if (filter.logChat && record.getLevel().intValue() == LogLevel.CHAT.intValue()) {
                                    writeRecord(record);
                                } else if (filter.logDebug && record.getLevel().intValue() == LogLevel.DEBUG.intValue()) {
                                    writeRecord(record);
                                } else if (filter.logInfo && record.getLevel().intValue() == LogLevel.INFO.intValue()) {
                                    writeRecord(record);
                                } else if (filter.logWarnings && record.getLevel().intValue() == LogLevel.WARNING.intValue()) {
                                    writeRecord(record);
                                } else if (filter.logSevere && record.getLevel().intValue() == LogLevel.SEVERE.intValue()) {
                                    writeRecord(record);
                                }
                            }
                        }
                    } catch (BadLocationException ex) {
                        Logger.getLogger(ServerGUI.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            });
        }

        @Override
        public void publish(LogRecord record) {
            super.publish(record);
            flush();

            records.add(record);

            if (filter.logAll) {
                writeRecord(record);
            } else {
                if (filter.logChat && record.getLevel().intValue() == LogLevel.CHAT.intValue()) {
                    writeRecord(record);
                } else if (filter.logDebug && record.getLevel().intValue() == LogLevel.DEBUG.intValue()) {
                    writeRecord(record);
                } else if (filter.logInfo && record.getLevel().intValue() == LogLevel.INFO.intValue()) {
                    writeRecord(record);
                } else if (filter.logWarnings && record.getLevel().intValue() == LogLevel.WARNING.intValue()) {
                    writeRecord(record);
                } else if (filter.logSevere && record.getLevel().intValue() == LogLevel.SEVERE.intValue()) {
                    writeRecord(record);
                }
            }
        }

        private void writeRecord(LogRecord record) {
            if (textPane != null) {
                /*
                 Throwable throwable = record.getThrown();
                
                 if (throwable != null) {
                 StringWriter stringwriter = new StringWriter();
                 throwable.printStackTrace(new PrintWriter(stringwriter));
                 stringwriter.toString();
                 }
                 */

                java.awt.EventQueue.invokeLater(new Runnable() {
                    public void run() {
                        StyleConstants.setBold(dateKeyword, false);
                        StyleConstants.setBold(levelKeyword, true);
                        StyleConstants.setBold(messageKeyword, false);

                        Level level = record.getLevel();
                        switch (level.getName()) {
                            case "FINEST":
                            case "FINER":
                            case "FINE":
                            case "CONFIG":
                            default:
                                StyleConstants.setForeground(dateKeyword, Color.black);
                                StyleConstants.setForeground(levelKeyword, Color.black);
                                StyleConstants.setForeground(messageKeyword, Color.black);
                                break;
                            case "INFO":
                                StyleConstants.setForeground(dateKeyword, Color.black);
                                StyleConstants.setForeground(levelKeyword, Color.blue);
                                StyleConstants.setForeground(messageKeyword, Color.black);
                                break;
                            case "WARNING":
                                StyleConstants.setBold(messageKeyword, true);

                                StyleConstants.setForeground(levelKeyword, warningColor);
                                StyleConstants.setForeground(messageKeyword, warningColor);
                                break;
                            case "SEVERE":
                                StyleConstants.setBold(messageKeyword, true);

                                StyleConstants.setForeground(levelKeyword, Color.red);
                                StyleConstants.setForeground(messageKeyword, Color.red);
                                break;
                            case "CHAT":
                                StyleConstants.setForeground(dateKeyword, Color.black);
                                StyleConstants.setForeground(levelKeyword, ChatFormatCode.DARK_GREEN);
                                StyleConstants.setForeground(messageKeyword, Color.black);
                                break;
                            case "DEBUG":
                                StyleConstants.setForeground(dateKeyword, Color.black);
                                StyleConstants.setForeground(levelKeyword, ChatFormatCode.DARK_PURPLE);
                                StyleConstants.setForeground(messageKeyword, Color.black);
                                break;
                        }

                        try {
                            append(dateFormat.format(record.getMillis()), dateKeyword);
                            append(" [" + record.getLevel().getName().toUpperCase() + "]: ", levelKeyword);
                            if (level.getName().equals("CHAT")) {
                                writeChatString(formatter.formatMessage(record));
                            } else {
                                append(formatter.formatMessage(record), messageKeyword);
                            }
                            append("\n", messageKeyword);
                        } catch (Exception e) {

                        }
                    }
                });
            }
        }
    }

    private class LogFilter {

        protected boolean logAll = false;
        protected boolean logDebug = false;
        protected boolean logChat = true;
        protected boolean logInfo = true;
        protected boolean logWarnings = true;
        protected boolean logSevere = true;

        public void shouldLogDebug(boolean status) {
            logDebug = status;
        }

        public void shouldLogChat(boolean status) {
            logChat = status;
        }

        public void shouldLogInfo(boolean status) {
            logInfo = status;
        }

        public void shouldLogWarnings(boolean status) {
            logWarnings = status;
        }

        public void shouldLogSevere(boolean status) {
            logSevere = status;
        }

        public void shouldLogAll(boolean status) {
            logAll = status;
        }
    }
}
